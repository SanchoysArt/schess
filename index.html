<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Полноценные шахматы</title>
<style>
body {
  margin: 0;
  background: #111;
  color: white;
  font-family: system-ui;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.container {
  display: flex;
  gap: 20px;
}

.board {
  display: grid;
  grid-template-columns: repeat(8, 70px);
  grid-template-rows: repeat(8, 70px);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 0 25px black;
}

.square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 42px;
  cursor: pointer;
  user-select: none;
}

.light { background: #f0d9b5; }
.dark { background: #b58863; }

.square.move {
  box-shadow: inset 0 0 0 4px rgba(0,0,0,.3);
}

.square.capture {
  box-shadow: inset 0 0 0 4px rgba(255,0,0,.6);
}

.panel {
  width: 260px;
  background: #1f1f1f;
  border-radius: 12px;
  padding: 12px;
  display: flex;
  flex-direction: column;
}

.status {
  text-align: center;
  margin-bottom: 10px;
}

.moves {
  flex: 1;
  background: #121212;
  border-radius: 6px;
  padding: 8px;
  overflow-y: auto;
  font-size: 14px;
}

button {
  margin-top: 10px;
  padding: 10px;
  border: none;
  border-radius: 8px;
  background: #4caf50;
  color: white;
  cursor: pointer;
}
</style>
</head>

<body>
<div class="container">
  <div id="board" class="board"></div>

  <div class="panel">
    <div id="status" class="status"></div>
    <div id="moves" class="moves"></div>
    <button onclick="newGame()">Новая партия</button>
  </div>
</div>

<script>
const PIECES = {
  r:"♜", n:"♞", b:"♝", q:"♛", k:"♚", p:"♟",
  R:"♖", N:"♘", B:"♗", Q:"♕", K:"♔", P:"♙"
};

let board, turn, selected, legalMoves, history;
let castling, enPassant;

const boardEl = document.getElementById("board");
const statusEl = document.getElementById("status");
const movesEl = document.getElementById("moves");

function newGame() {
  board = [
    "rnbqkbnr",
    "pppppppp",
    "........",
    "........",
    "........",
    "........",
    "PPPPPPPP",
    "RNBQKBNR"
  ].map(r=>r.split(""));
  turn = "white";
  selected = null;
  history = [];
  castling = {K:true,Q:true,k:true,q:true};
  enPassant = null;
  render();
  updateStatus();
  updateMoves();
}

function render() {
  boardEl.innerHTML = "";
  for(let y=0;y<8;y++) for(let x=0;x<8;x++) {
    const s = document.createElement("div");
    s.className = `square ${(x+y)%2?"dark":"light"}`;
    s.onclick = ()=>clickSquare(x,y);

    if(selected && legalMoves.some(m=>m.x==x&&m.y==y))
      s.classList.add(board[y][x]=="."?"move":"capture");

    const p = board[y][x];
    if(p!=".") s.textContent = PIECES[p];
    boardEl.appendChild(s);
  }
}

function clickSquare(x,y){
  const p = board[y][x];
  if(selected){
    const move = legalMoves.find(m=>m.x==x&&m.y==y);
    if(move) makeMove(move);
    selected=null;
    legalMoves=[];
    render();
    return;
  }
  if(p!="." && isOwn(p)){
    selected={x,y};
    legalMoves = getLegalMoves(x,y);
    render();
  }
}

function isOwn(p){
  return turn=="white"?p==p.toUpperCase():p==p.toLowerCase();
}

function makeMove(m){
  board[m.y][m.x] = m.piece;
  board[m.fromY][m.fromX] = ".";
  if(m.promote) board[m.y][m.x]=m.promote;
  history.push(m.notation);
  turn = turn=="white"?"black":"white";
  updateStatus();
  updateMoves();
}

function getLegalMoves(x,y){
  const pseudo = getPseudoMoves(x,y);
  return pseudo.filter(m=>!leavesKingInCheck(m));
}

/* ====== ПОЛНАЯ ГЕНЕРАЦИЯ ХОДОВ ====== */
function getPseudoMoves(x,y){
  const p = board[y][x];
  const moves=[];
  const isWhite = p==p.toUpperCase();
  const dir = isWhite?-1:1;

  if(p.toLowerCase()=="p"){
    if(board[y+dir]?.[x]==".")
      moves.push(moveObj(x,y,x,y+dir,p));
    for(let dx of [-1,1]){
      if(board[y+dir]?.[x+dx] && board[y+dir][x+dx]!="." &&
        isOwn(board[y+dir][x+dx])==false)
        moves.push(moveObj(x,y,x+dx,y+dir,p));
    }
    if((y==6&&isWhite)||(y==1&&!isWhite))
      if(board[y+dir][x]=="."&&board[y+2*dir][x]==".")
        moves.push(moveObj(x,y,x,y+2*dir,p));
  }

  const steps = {
    n:[[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]],
    b:[[1,1],[1,-1],[-1,1],[-1,-1]],
    r:[[1,0],[-1,0],[0,1],[0,-1]],
    q:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
    k:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]
  };

  if(steps[p.toLowerCase()]){
    for(const [dx,dy] of steps[p.toLowerCase()]){
      let nx=x+dx, ny=y+dy;
      while(nx>=0&&nx<8&&ny>=0&&ny<8){
        if(board[ny][nx]==".")
          moves.push(moveObj(x,y,nx,ny,p));
        else {
          if(!isOwn(board[ny][nx]))
            moves.push(moveObj(x,y,nx,ny,p));
          break;
        }
        if(p.toLowerCase()=="n"||p.toLowerCase()=="k") break;
        nx+=dx; ny+=dy;
      }
    }
  }
  return moves;
}

function moveObj(fx,fy,tx,ty,p){
  return {
    fromX:fx, fromY:fy,
    x:tx, y:ty,
    piece:p,
    notation:p+String.fromCharCode(97+fx)+(8-fy)+"-"+String.fromCharCode(97+tx)+(8-ty)
  };
}

function leavesKingInCheck(m){
  const copy = board.map(r=>r.slice());
  copy[m.y][m.x]=m.piece;
  copy[m.fromY][m.fromX]=".";
  return isKingAttacked(copy,turn);
}

function isKingAttacked(b,side){
  let kx,ky;
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=b[y][x];
    if(p.toLowerCase()=="k" && ((side=="white"&&p=="K")||(side=="black"&&p=="k"))){
      kx=x;ky=y;
    }
  }
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=b[y][x];
    if(p!="." && ((side=="white"&&p==p.toLowerCase())||(side=="black"&&p==p.toUpperCase()))){
      const temp=board;
      board=b;
      const attacks=getPseudoMoves(x,y);
      board=temp;
      if(attacks.some(a=>a.x==kx&&a.y==ky)) return true;
    }
  }
  return false;
}

function updateStatus(){
  statusEl.textContent="Ход: "+(turn=="white"?"Белые":"Чёрные");
}

function updateMoves(){
  movesEl.innerHTML=history.map((m,i)=>`${i+1}. ${m}`).join("<br>");
}

newGame();
</script>
</body>
</html>