<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–®–∞—Ö–º–∞—Ç—ã —Å –ò–ò</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- chessboard.css -->
<link rel="stylesheet"
 href="https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

<style>
body {
  margin: 0;
  font-family: 'Segoe UI', system-ui, Arial;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  color: #fff;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
}

.screen {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 800px;
}

.screen.active {
  display: flex;
}

h1 {
  margin: 16px 0 24px;
  font-size: 2.5em;
  background: linear-gradient(45deg, #f0d9b5, #b58863);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
}

.menu {
  text-align: center;
}

.menu button, select {
  font-size: 1.1em;
  padding: 14px 28px;
  margin: 10px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 600;
}

.menu button {
  background: linear-gradient(45deg, #f0d9b5, #b58863);
  color: #000;
  min-width: 200px;
}

.menu button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

select {
  background: #2c3e50;
  color: white;
  min-width: 220px;
}

#board-wrapper {
  width: 92vw;
  max-width: 500px;
  margin: 0 auto;
  background: #2c3e50;
  padding: 15px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

#board {
  width: 100%;
}

#status {
  margin-top: 20px;
  padding: 15px 25px;
  background: #2c3e50;
  border-radius: 10px;
  font-size: 1.2em;
  text-align: center;
  min-width: 300px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.topbar {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.topbar button {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s ease;
  background: #34495e;
  color: white;
}

.topbar button:hover {
  background: #4a6572;
  transform: translateY(-2px);
}

#controls {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

#controls button {
  padding: 10px 20px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

#controls button:hover {
  background: #2980b9;
}

.info-panel {
  display: flex;
  justify-content: space-around;
  width: 100%;
  margin-top: 20px;
  gap: 20px;
}

.info-box {
  background: #2c3e50;
  padding: 15px;
  border-radius: 10px;
  flex: 1;
  text-align: center;
}

.info-label {
  font-size: 0.9em;
  color: #95a5a6;
  margin-bottom: 5px;
}

.info-value {
  font-size: 1.2em;
  font-weight: bold;
  color: #f0d9b5;
}

#move-history {
  background: #2c3e50;
  padding: 15px;
  border-radius: 10px;
  margin-top: 20px;
  max-height: 200px;
  overflow-y: auto;
  width: 100%;
}

.history-move {
  padding: 5px 10px;
  margin: 2px;
  background: #34495e;
  border-radius: 4px;
  display: inline-block;
}

.turn-indicator {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: inline-block;
  margin-left: 10px;
}

.turn-white {
  background: #f0d9b5;
}

.turn-black {
  background: #b58863;
}

@media (max-width: 768px) {
  #board-wrapper {
    max-width: 400px;
  }
  
  .info-panel {
    flex-direction: column;
  }
  
  h1 {
    font-size: 2em;
  }
}
</style>
</head>
<body>

<!-- MENU -->
<div id="menu" class="screen active menu">
  <h1>‚ôü –®–∞—Ö–º–∞—Ç—ã —Å –ò–ò</h1>
  
  <div style="margin-bottom: 30px;">
    <select id="difficulty">
      <option value="1">üë∂ –õ—ë–≥–∫–∏–π (–Ω–æ–≤–∏—á–æ–∫)</option>
      <option value="2" selected>üß† –°—Ä–µ–¥–Ω–∏–π (–ª—é–±–∏—Ç–µ–ª—å)</option>
      <option value="3">üî• –°–ª–æ–∂–Ω—ã–π (–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π)</option>
      <option value="4">ü§ñ –≠–∫—Å–ø–µ—Ä—Ç (–º–∞—Å—Ç–µ—Ä)</option>
    </select>
  </div>
  
  <div>
    <select id="color">
      <option value="white">‚ö™ –ò–≥—Ä–∞—Ç—å –±–µ–ª—ã–º–∏</option>
      <option value="black">‚ö´ –ò–≥—Ä–∞—Ç—å —á—ë—Ä–Ω—ã–º–∏</option>
      <option value="random">üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç</option>
    </select>
  </div>
  
  <div style="margin-top: 40px;">
    <button onclick="startGame()">üéÆ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    <button onclick="showRules()">üìñ –ü—Ä–∞–≤–∏–ª–∞</button>
  </div>
</div>

<!-- GAME -->
<div id="game" class="screen">
  <div class="topbar">
    <button onclick="backToMenu()">‚Üê –ú–µ–Ω—é</button>
    <button onclick="newGame()">üîÑ –ù–æ–≤–∞—è –ø–∞—Ä—Ç–∏—è</button>
    <button onclick="togglePause()">‚è∏Ô∏è –ü–∞—É–∑–∞</button>
    <button onclick="undoMove()">‚Ü∂ –û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
  </div>

  <div id="board-wrapper">
    <div id="board"></div>
  </div>

  <div id="status"></div>
  
  <div class="info-panel">
    <div class="info-box">
      <div class="info-label">–°–õ–û–ñ–ù–û–°–¢–¨</div>
      <div class="info-value" id="difficulty-display">–°—Ä–µ–¥–Ω—è—è</div>
    </div>
    <div class="info-box">
      <div class="info-label">–•–û–î</div>
      <div class="info-value">
        <span id="turn-display">–ë–µ–ª—ã–µ</span>
        <span class="turn-indicator turn-white"></span>
      </div>
    </div>
    <div class="info-box">
      <div class="info-label">–•–û–î–û–í</div>
      <div class="info-value" id="move-count">0</div>
    </div>
  </div>
  
  <div id="move-history">
    <div style="color: #95a5a6; margin-bottom: 10px;">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤:</div>
    <div id="history-list"></div>
  </div>
</div>

<!-- RULES MODAL -->
<div id="rules-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); justify-content: center; align-items: center; z-index: 1000;">
  <div style="background: #2c3e50; padding: 30px; border-radius: 15px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
    <h2 style="color: #f0d9b5;">üìñ –ü—Ä–∞–≤–∏–ª–∞ —à–∞—Ö–º–∞—Ç</h2>
    <ul style="line-height: 1.6;">
      <li><strong>–¶–µ–ª—å –∏–≥—Ä—ã:</strong> –ü–æ—Å—Ç–∞–≤–∏—Ç—å –º–∞—Ç –∫–æ—Ä–æ–ª—é –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞.</li>
      <li><strong>–•–æ–¥—ã —Ñ–∏–≥—É—Ä:</strong>
        <ul>
          <li>‚ôô –ü–µ—à–∫–∞: –Ω–∞ 1 –∫–ª–µ—Ç–∫—É –≤–ø–µ—Ä—ë–¥ (–ø–µ—Ä–≤—ã–π —Ö–æ–¥ –º–æ–∂–Ω–æ –Ω–∞ 2), –±—å—ë—Ç –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏</li>
          <li>‚ôñ –õ–∞–¥—å—è: –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏</li>
          <li>‚ôò –ö–æ–Ω—å: –±—É–∫–≤–æ–π "–ì" (2+1 –∫–ª–µ—Ç–∫–∏)</li>
          <li>‚ôó –°–ª–æ–Ω: –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏</li>
          <li>‚ôï –§–µ—Ä–∑—å: –≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏</li>
          <li>‚ôî –ö–æ—Ä–æ–ª—å: –Ω–∞ 1 –∫–ª–µ—Ç–∫—É –≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏</li>
        </ul>
      </li>
      <li><strong>–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã:</strong> –†–æ–∫–∏—Ä–æ–≤–∫–∞, –≤–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ, –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏.</li>
      <li><strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> –ú–∞—Ç, –ø–∞—Ç, –Ω–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é –∏–ª–∏ –∏–∑-–∑–∞ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏.</li>
    </ul>
    <button onclick="hideRules()" style="margin-top: 20px; padding: 10px 20px; background: #f0d9b5; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">–ó–∞–∫—Ä—ã—Ç—å</button>
  </div>
</div>

<!-- LIBRARIES -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/chess.js@1.0.0/chess.min.js"></script>
<script src="https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

<script>
let board = null;
let game = null;
let level = 2;
let playerColor = 'white';
let moveHistory = [];
let isPaused = false;
let gameState = 'active';

const pieceValues = {
  'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0
};

function startGame() {
  level = +document.getElementById("difficulty").value;
  const colorChoice = document.getElementById("color").value;
  
  if (colorChoice === 'random') {
    playerColor = Math.random() > 0.5 ? 'white' : 'black';
  } else {
    playerColor = colorChoice;
  }
  
  document.getElementById("menu").classList.remove("active");
  document.getElementById("game").classList.add("active");
  initGame();
}

function backToMenu() {
  document.getElementById("game").classList.remove("active");
  document.getElementById("menu").classList.add("active");
  if (board) board.destroy();
}

function showRules() {
  document.getElementById('rules-modal').style.display = 'flex';
}

function hideRules() {
  document.getElementById('rules-modal').style.display = 'none';
}

function initGame() {
  game = new Chess();
  moveHistory = [];
  
  const difficultyNames = ['–õ—ë–≥–∫–∏–π', '–°—Ä–µ–¥–Ω–∏–π', '–°–ª–æ–∂–Ω—ã–π', '–≠–∫—Å–ø–µ—Ä—Ç'];
  document.getElementById('difficulty-display').textContent = difficultyNames[level-1];
  
  const config = {
    draggable: true,
    position: 'start',
    orientation: playerColor,
    onDrop: onDrop,
    onSnapEnd: () => board.position(game.fen())
  };
  
  board = Chessboard('board', config);
  
  if (playerColor === 'black') {
    setTimeout(makeAIMove, 500);
  }
  
  updateStatus();
  updateTurnDisplay();
  updateMoveCount();
  updateHistory();
}

function newGame() {
  if (board) board.destroy();
  initGame();
  isPaused = false;
  gameState = 'active';
}

function togglePause() {
  isPaused = !isPaused;
  document.querySelector('button[onclick="togglePause()"]').textContent = 
    isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '‚è∏Ô∏è –ü–∞—É–∑–∞';
  board.draggable = !isPaused;
}

function undoMove() {
  if (moveHistory.length < 1) return;
  
  game.undo();
  moveHistory.pop();
  
  if (moveHistory.length > 0) {
    game.undo();
    moveHistory.pop();
  }
  
  board.position(game.fen());
  updateStatus();
  updateTurnDisplay();
  updateMoveCount();
  updateHistory();
}

function onDrop(source, target) {
  if (isPaused || gameState !== 'active') return 'snapback';
  
  const move = game.move({
    from: source,
    to: target,
    promotion: 'q'
  });

  if (move === null) return 'snapback';
  
  moveHistory.push(move);
  updateStatus();
  updateTurnDisplay();
  updateMoveCount();
  updateHistory();
  
  if (game.game_over()) {
    gameState = 'finished';
    return;
  }
  
  setTimeout(makeAIMove, 300);
}

function evaluateBoard(position) {
  let score = 0;
  const board = position.board();
  
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const square = board[i][j];
      if (square) {
        const value = pieceValues[square.type];
        const multiplier = square.color === 'w' ? 1 : -1;
        score += value * multiplier;
        
        // –ë–æ–Ω—É—Å –∑–∞ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ –¥–ª—è –ø–µ—à–µ–∫ –∏ –∫–æ–Ω–µ–π
        if (square.type === 'p' || square.type === 'n') {
          const centerDist = Math.abs(3.5 - j) + Math.abs(3.5 - i);
          score += (14 - centerDist) * 0.01 * multiplier;
        }
      }
    }
  }
  return score;
}

function minimax(position, depth, alpha, beta, maximizingPlayer) {
  if (depth === 0 || position.game_over()) {
    return evaluateBoard(position);
  }
  
  const moves = position.moves({ verbose: true });
  
  if (maximizingPlayer) {
    let maxEval = -Infinity;
    for (const move of moves) {
      position.move(move);
      const evaluation = minimax(position, depth - 1, alpha, beta, false);
      position.undo();
      maxEval = Math.max(maxEval, evaluation);
      alpha = Math.max(alpha, evaluation);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const move of moves) {
      position.move(move);
      const evaluation = minimax(position, depth - 1, alpha, beta, true);
      position.undo();
      minEval = Math.min(minEval, evaluation);
      beta = Math.min(beta, evaluation);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function makeAIMove() {
  if (isPaused || gameState !== 'active' || game.game_over()) return;
  
  const moves = game.moves({ verbose: true });
  if (moves.length === 0) return;
  
  let bestMove = null;
  let bestValue = playerColor === 'white' ? Infinity : -Infinity;
  
  // –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –≤—ã–±–∏—Ä–∞–µ–º –≥–ª—É–±–∏–Ω—É –ø–æ–∏—Å–∫–∞
  const depths = [1, 2, 3, 4];
  const searchDepth = depths[level - 1];
  
  for (const move of moves) {
    game.move(move);
    
    let moveValue;
    if (level === 1) {
      // –õ—ë–≥–∫–∏–π —É—Ä–æ–≤–µ–Ω—å: —Å–ª—É—á–∞–π–Ω—ã–µ —Ö–æ–¥—ã —Å –±–∞–∑–æ–≤–æ–π –æ—Ü–µ–Ω–∫–æ–π
      moveValue = Math.random() * 100 + evaluateBoard(game);
    } else {
      // –ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ —É—Ä–æ–≤–Ω–∏: –º–∏–Ω–∏–º–∞–∫—Å —Å –∞–ª—å—Ñ–∞-–±–µ—Ç–∞ –æ—Ç—Å–µ—á–µ–Ω–∏–µ–º
      moveValue = minimax(game, searchDepth - 1, -Infinity, Infinity, playerColor === 'white');
    }
    
    game.undo();
    
    if (playerColor === 'white') {
      if (moveValue < bestValue) {
        bestValue = moveValue;
        bestMove = move;
      }
    } else {
      if (moveValue > bestValue) {
        bestValue = moveValue;
        bestMove = move;
      }
    }
  }
  
  // –ò–Ω–æ–≥–¥–∞ –¥–µ–ª–∞–µ–º —Å—É–±–æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã –Ω–∞ –ª—ë–≥–∫–∏—Ö —É—Ä–æ–≤–Ω—è—Ö
  if (level === 1 && Math.random() < 0.3) {
    bestMove = moves[Math.floor(Math.random() * moves.length)];
  }
  
  if (bestMove) {
    game.move(bestMove);
    moveHistory.push(bestMove);
    board.position(game.fen());
    updateStatus();
    updateTurnDisplay();
    updateMoveCount();
    updateHistory();
    
    if (game.game_over()) {
      gameState = 'finished';
    }
  }
}

function updateStatus() {
  let text = '';
  
  if (game.in_checkmate()) {
    text = `üéâ –ú–∞—Ç! ${game.turn() === 'w' ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ'} –ø–æ–±–µ–¥–∏–ª–∏!`;
  } else if (game.in_draw()) {
    text = 'ü§ù –ù–∏—á—å—è!';
  } else if (game.in_stalemate()) {
    text = 'ü§ù –ü–∞—Ç!';
  } else if (game.in_threefold_repetition()) {
    text = 'ü§ù –ù–∏—á—å—è –∏–∑-–∑–∞ —Ç—Ä–æ–µ–∫—Ä–∞—Ç–Ω–æ–≥–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è!';
  } else if (game.insufficient_material()) {
    text = 'ü§ù –ù–∏—á—å—è –∏–∑-–∑–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞!';
  } else {
    text = game.turn() === 'w' ? '–•–æ–¥ –±–µ–ª—ã—Ö' : '–•–æ–¥ —á—ë—Ä–Ω—ã—Ö';
    if (game.in_check()) text += ' ‚Äî –®–ê–•!';
  }
  
  document.getElementById('status').textContent = text;
}

function updateTurnDisplay() {
  const turn = game.turn() === 'w' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
  document.getElementById('turn-display').textContent = turn;
  
  const indicator = document.querySelector('.turn-indicator');
  indicator.className = 'turn-indicator ' + (game.turn() === 'w' ? 'turn-white' : 'turn-black');
}

function updateMoveCount() {
  document.getElementById('move-count').textContent = Math.ceil(moveHistory.length / 2);
}

function updateHistory() {
  const historyList = document.getElementById('history-list');
  historyList.innerHTML = '';
  
  for (let i = 0; i < moveHistory.length; i += 2) {
    const moveNumber = Math.floor(i / 2) + 1;
    const whiteMove = moveHistory[i] ? moveHistory[i].san : '';
    const blackMove = moveHistory[i + 1] ? moveHistory[i + 1].san : '';
    
    const moveElement = document.createElement('div');
    moveElement.innerHTML = `
      <span style="color: #95a5a6; margin-right: 10px;">${moveNumber}.</span>
      <span class="history-move" style="background: #f0d9b5; color: #000">${whiteMove}</span>
      <span class="history-move" style="background: #b58863; color: #000">${blackMove}</span>
    `;
    historyList.appendChild(moveElement);
  }
  
  // –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –≤–Ω–∏–∑
  historyList.scrollTop = historyList.scrollHeight;
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
document.addEventListener('DOMContentLoaded', function() {
  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–æ—Å–∫–∏
  function resizeBoard() {
    const width = Math.min(window.innerWidth - 40, 500);
    if (board) {
      board.resize();
    }
  }
  
  window.addEventListener('resize', resizeBoard);
  resizeBoard();
});
</script>

</body>
</html>