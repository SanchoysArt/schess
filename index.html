<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ú–æ–∏ —à–∞—Ö–º–∞—Ç—ã</title>

<style>
/* ====== –°–ë–†–û–° ====== */
* {
  box-sizing: border-box;
  user-select: none;
}

/* ====== –û–°–ù–û–í–ê ====== */
body {
  margin: 0;
  background: #111;
  color: #eee;
  font-family: system-ui, sans-serif;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* ====== –≠–ö–†–ê–ù–´ ====== */
.screen {
  width: 100%;
  max-width: 520px;
  background: #1b1b1b;
  padding: 20px;
  border-radius: 14px;
  box-shadow: 0 0 30px black;
}

.hidden {
  display: none;
}

h1 {
  text-align: center;
  margin-top: 0;
}

/* ====== –ú–ï–ù–Æ ====== */
label {
  display: block;
  margin-top: 14px;
  font-size: 14px;
  opacity: 0.9;
}

select, button {
  width: 100%;
  margin-top: 8px;
  padding: 12px;
  font-size: 16px;
  border-radius: 10px;
  border: none;
}

button {
  background: #4caf50;
  color: white;
  cursor: pointer;
}

button.secondary {
  background: #333;
}

/* ====== –ò–ì–†–ê ====== */
#topBar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  font-size: 14px;
}

#comment {
  opacity: 0.8;
  font-style: italic;
}

#boardWrapper {
  width: 100%;
  aspect-ratio: 1 / 1;
}

#board {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  border-radius: 12px;
  overflow: hidden;
}

/* ====== –ö–õ–ï–¢–ö–ò ====== */
.square {
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: clamp(32px, 6vw, 48px);
  cursor: pointer;
}

.light { background: #f0d9b5; }
.dark  { background: #b58863; }

/* ====== –ü–û–î–°–í–ï–¢–ö–ê ====== */
.square.selected {
  outline: 4px solid rgba(0,0,0,0.5);
}

.square.move::after {
  content: "";
  width: 22%;
  height: 22%;
  border-radius: 50%;
  background: rgba(0,0,0,0.4);
}

.square.capture::after {
  content: "";
  width: 70%;
  height: 70%;
  border-radius: 50%;
  border: 4px solid red;
}

/* ====== –ö–ù–û–ü–ö–ò ====== */
#controls {
  display: flex;
  gap: 10px;
  margin-top: 12px;
}
#controls button {
  flex: 1;
}
</style>
</head>

<body>

<!-- ================= –ú–ï–ù–Æ ================= -->
<div id="menu" class="screen">
  <h1>‚ôü –®–∞—Ö–º–∞—Ç—ã</h1>

  <label>–¶–≤–µ—Ç —Ñ–∏–≥—É—Ä</label>
  <select id="playerColor">
    <option value="white">–ë–µ–ª—ã–µ</option>
    <option value="black">–ß—ë—Ä–Ω—ã–µ</option>
  </select>

  <label>–°–ª–æ–∂–Ω–æ—Å—Ç—å –ò–ò</label>
  <select id="difficulty">
    <option value="1">1 ‚Äî –û—á–µ–Ω—å –ª–µ–≥–∫–æ</option>
    <option value="2">2 ‚Äî –õ–µ–≥–∫–æ</option>
    <option value="3">3 ‚Äî –°—Ä–µ–¥–Ω–µ</option>
    <option value="4">4 ‚Äî –°–ª–æ–∂–Ω–æ</option>
    <option value="5">5 ‚Äî –û—á–µ–Ω—å —Å–ª–æ–∂–Ω–æ</option>
  </select>

  <button onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
</div>

<!-- ================= –ò–ì–†–ê ================= -->
<div id="game" class="screen hidden">

  <div id="topBar">
    <div id="status">–í–∞—à —Ö–æ–¥</div>
    <div id="comment"></div>
  </div>

  <div id="boardWrapper">
    <div id="board"></div>
  </div>

  <div id="controls">
    <button class="secondary" onclick="undoMove()">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
    <button class="secondary" onclick="resign()">üè≥ –°–¥–∞—Ç—å—Å—è</button>
    <button onclick="restart()">‚Üª –ó–∞–Ω–æ–≤–æ</button>
  </div>

</div>

<script>
/* =====================================================
   –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
===================================================== */

let state = {
  board: [],           // 8x8
  turn: "white",       // white | black
  playerColor: "white",
  difficulty: 1,
  selected: null,      // {x,y}
  legalMoves: [],
  history: [],
  gameOver: false
};

/* =====================================================
   –§–ò–ì–£–†–´ (UNICODE)
===================================================== */

const PIECES = {
  wp: "‚ôô", wr: "‚ôñ", wn: "‚ôò", wb: "‚ôó", wq: "‚ôï", wk: "‚ôî",
  bp: "‚ôü", br: "‚ôú", bn: "‚ôû", bb: "‚ôù", bq: "‚ôõ", bk: "‚ôö"
};

/* =====================================================
   –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
===================================================== */

function startGame() {
  state.playerColor = document.getElementById("playerColor").value;
  state.difficulty  = parseInt(document.getElementById("difficulty").value);

  document.getElementById("menu").classList.add("hidden");
  document.getElementById("game").classList.remove("hidden");

  initBoard();
  renderBoard();
  updateStatus();
}

/* =====================================================
   –ù–ê–ß–ê–õ–¨–ù–ê–Ø –ü–û–ó–ò–¶–ò–Ø
===================================================== */

function initBoard() {
  state.board = [
    ["br","bn","bb","bq","bk","bb","bn","br"],
    ["bp","bp","bp","bp","bp","bp","bp","bp"],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["","","","","","","",""],
    ["wp","wp","wp","wp","wp","wp","wp","wp"],
    ["wr","wn","wb","wq","wk","wb","wn","wr"]
  ];

  state.turn = "white";
  state.selected = null;
  state.legalMoves = [];
  state.history = [];
  state.gameOver = false;
}

/* =====================================================
   –û–¢–†–ò–°–û–í–ö–ê –î–û–°–ö–ò
===================================================== */

function renderBoard() {
  const boardEl = document.getElementById("board");
  boardEl.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {

      const square = document.createElement("div");
      square.className = "square " + ((x + y) % 2 === 0 ? "light" : "dark");

      square.dataset.x = x;
      square.dataset.y = y;

      // –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–π
      if (state.selected && state.selected.x === x && state.selected.y === y) {
        square.classList.add("selected");
      }

      // –ø–æ–¥—Å–≤–µ—Ç–∫–∞ —Ö–æ–¥–æ–≤
      if (state.legalMoves.some(m => m.x === x && m.y === y)) {
        square.classList.add(
          state.board[y][x] ? "capture" : "move"
        );
      }

      const piece = state.board[y][x];
      if (piece) {
        square.textContent = PIECES[piece];
      }

      square.addEventListener("click", () => onSquareClick(x, y));
      boardEl.appendChild(square);
    }
  }
}

/* =====================================================
   –ö–õ–ò–ö –ü–û –ö–õ–ï–¢–ö–ï
===================================================== */

function onSquareClick(x, y) {
  if (state.gameOver) return;

  const piece = state.board[y][x];

  if (state.selected) {
    const move = state.legalMoves.find(m => m.x === x && m.y === y);
    if (move) {
      makeMove(state.selected.x, state.selected.y, x, y);
      return;
    }
    state.selected = null;
    state.legalMoves = [];
    renderBoard();
    return;
  }

  if (piece && piece[0] === state.turn[0]) {
    state.selected = { x, y };
    state.legalMoves = []; // –ü–û–ö–ê –ü–£–°–¢–û
    renderBoard();
  }
}

/* =====================================================
   –•–û–î (–ü–û–ö–ê –ó–ê–ì–õ–£–®–ö–ê)
===================================================== */

function makeMove(fx, fy, tx, ty) {
  const piece = state.board[fy][fx];
  state.board[fy][fx] = "";
  state.board[ty][tx] = piece;

  state.turn = state.turn === "white" ? "black" : "white";
  state.selected = null;
  state.legalMoves = [];

  renderBoard();
  updateStatus();
}

/* =====================================================
   UI
===================================================== */

function updateStatus() {
  document.getElementById("status").textContent =
    state.turn === state.playerColor ? "–í–∞—à —Ö–æ–¥" : "–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞";
}

function undoMove() {
  // –±—É–¥–µ—Ç –ø–æ–∑–∂–µ
}

function resign() {
  alert("–í—ã —Å–¥–∞–ª–∏—Å—å");
  restart();
}

function restart() {
  location.reload();
}
<script>
/* =====================================================
   –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
===================================================== */

function inBounds(x, y) {
  return x >= 0 && x < 8 && y >= 0 && y < 8;
}

function cloneBoard(board) {
  return board.map(row => row.slice());
}

function isWhite(piece) {
  return piece && piece[0] === "w";
}

function isBlack(piece) {
  return piece && piece[0] === "b";
}

function enemy(piece) {
  return piece && piece[0] !== state.turn[0];
}

/* =====================================================
   –ì–ï–ù–ï–†–ê–¶–ò–Ø –•–û–î–û–í
===================================================== */

function getLegalMoves(x, y) {
  const piece = state.board[y][x];
  if (!piece) return [];

  const pseudo = getPseudoMoves(x, y, piece);
  return pseudo.filter(m => !leavesKingInCheck(x, y, m.x, m.y));
}

function getPseudoMoves(x, y, piece) {
  const moves = [];
  const color = piece[0];
  const type = piece[1];

  const dir = color === "w" ? -1 : 1;

  /* ===== –ü–ï–®–ö–ê ===== */
  if (type === "p") {
    // –≤–ø–µ—Ä—ë–¥
    if (inBounds(x, y + dir) && !state.board[y + dir][x]) {
      moves.push({ x, y: y + dir });
      // –¥–≤–æ–π–Ω–æ–π —Ö–æ–¥
      const startRow = color === "w" ? 6 : 1;
      if (y === startRow && !state.board[y + dir * 2][x]) {
        moves.push({ x, y: y + dir * 2, double: true });
      }
    }
    // –≤–∑—è—Ç–∏—è
    for (let dx of [-1, 1]) {
      const nx = x + dx, ny = y + dir;
      if (inBounds(nx, ny) && state.board[ny][nx] && enemy(state.board[ny][nx])) {
        moves.push({ x: nx, y: ny, capture: true });
      }
    }
    // TODO: en passant (–¥–æ–±–∞–≤–∏–º –Ω–∏–∂–µ)
  }

  /* ===== –ö–û–ù–¨ ===== */
  if (type === "n") {
    const jumps = [
      [1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]
    ];
    jumps.forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if (!inBounds(nx,ny)) return;
      if (!state.board[ny][nx] || enemy(state.board[ny][nx]))
        moves.push({x:nx,y:ny});
    });
  }

  /* ===== –°–õ–û–ù / –õ–ê–î–¨–Ø / –§–ï–†–ó–¨ ===== */
  const sliders = {
    b: [[1,1],[1,-1],[-1,1],[-1,-1]],
    r: [[1,0],[-1,0],[0,1],[0,-1]],
    q: [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]
  };

  if (sliders[type]) {
    sliders[type].forEach(([dx,dy])=>{
      let nx=x+dx, ny=y+dy;
      while(inBounds(nx,ny)){
        if (!state.board[ny][nx]) {
          moves.push({x:nx,y:ny});
        } else {
          if (enemy(state.board[ny][nx])) moves.push({x:nx,y:ny,capture:true});
          break;
        }
        nx+=dx; ny+=dy;
      }
    });
  }

  /* ===== –ö–û–†–û–õ–¨ ===== */
  if (type === "k") {
    for (let dx=-1;dx<=1;dx++)
      for (let dy=-1;dy<=1;dy++) {
        if (dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if (!inBounds(nx,ny)) continue;
        if (!state.board[ny][nx] || enemy(state.board[ny][nx]))
          moves.push({x:nx,y:ny});
      }
    // —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è, –ø–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∏–∂–µ)
    // TODO
  }

  return moves;
}

/* =====================================================
   –ü–†–û–í–ï–†–ö–ê –®–ê–•–ê
===================================================== */

function leavesKingInCheck(fx, fy, tx, ty) {
  const boardCopy = cloneBoard(state.board);
  const piece = boardCopy[fy][fx];
  boardCopy[fy][fx] = "";
  boardCopy[ty][tx] = piece;
  return isKingInCheck(boardCopy, state.turn);
}

function isKingInCheck(board, color) {
  let kx, ky;
  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p = board[y][x];
      if (p === color[0]+"k") { kx=x; ky=y; }
    }

  const enemyColor = color === "white" ? "b" : "w";

  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p = board[y][x];
      if (p && p[0] === enemyColor) {
        const pseudo = getPseudoMoves(x,y,p);
        if (pseudo.some(m => m.x===kx && m.y===ky)) return true;
      }
    }
  return false;
}

/* =====================================================
   –û–ë–ù–û–í–õ–Ø–ï–ú –ö–õ–ò–ö
===================================================== */

const oldClick = onSquareClick;
onSquareClick = function(x,y){
  if (state.gameOver) return;

  const piece = state.board[y][x];

  if (state.selected) {
    const move = state.legalMoves.find(m=>m.x===x&&m.y===y);
    if (move) {
      makeMove(state.selected.x,state.selected.y,x,y);
      return;
    }
    state.selected=null;
    state.legalMoves=[];
    renderBoard();
    return;
  }

  if (piece && piece[0]===state.turn[0]) {
    state.selected={x,y};
    state.legalMoves=getLegalMoves(x,y);
    renderBoard();
  }
};

/* =====================================================
   –û–ë–ù–û–í–õ–Ø–ï–ú –•–û–î
===================================================== */

const oldMakeMove = makeMove;
makeMove = function(fx,fy,tx,ty){
  const piece = state.board[fy][fx];

  state.history.push({
    board: cloneBoard(state.board),
    turn: state.turn
  });

  state.board[fy][fx]="";
  state.board[ty][tx]=piece;

  // –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
  if (piece[1]==="p" && (ty===0 || ty===7)) {
    state.board[ty][tx]=piece[0]+"q";
  }

  state.turn = state.turn==="white"?"black":"white";
  state.selected=null;
  state.legalMoves=[];

  checkGameEnd();
  renderBoard();
  updateStatus();
};

/* =====================================================
   –ö–û–ù–ï–¶ –ò–ì–†–´
===================================================== */

function checkGameEnd() {
  let hasMove=false;
  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p=state.board[y][x];
      if (p && p[0]===state.turn[0]) {
        if (getLegalMoves(x,y).length>0) hasMove=true;
      }
    }

  if (!hasMove) {
    state.gameOver=true;
    if (isKingInCheck(state.board,state.turn)) {
      alert("–ú–∞—Ç");
    } else {
      alert("–ü–∞—Ç");
    }
  }
}

/* =====================================================
   –û–¢–ú–ï–ù–ê –•–û–î–ê
===================================================== */

undoMove = function(){
  if (!state.history.length) return;
  const last = state.history.pop();
  state.board = cloneBoard(last.board);
  state.turn = last.turn;
  state.gameOver=false;
  renderBoard();
  updateStatus();
};
</script>
/* =====================================================
   –°–ü–ï–¶–ò–ê–õ–¨–ù–´–ï –ü–†–ê–í–ò–õ–ê
===================================================== */

/* ----- —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Å–ø–µ—Ü—Ö–æ–¥–æ–≤ ----- */
state.castling = {
  w: { king: true, rookA: true, rookH: true },
  b: { king: true, rookA: true, rookH: true }
};
state.enPassant = null;

/* ----- —Ä–∞—Å—à–∏—Ä—è–µ–º —Ö–æ–¥—ã –ø–µ—à–∫–∏ (en passant) ----- */
const oldPseudo = getPseudoMoves;
getPseudoMoves = function(x, y, piece) {
  let moves = oldPseudo(x, y, piece);
  const color = piece[0];
  const type = piece[1];
  const dir = color === "w" ? -1 : 1;

  if (type === "p" && state.enPassant) {
    if (Math.abs(state.enPassant.x - x) === 1 &&
        state.enPassant.y === y + dir) {
      moves.push({
        x: state.enPassant.x,
        y: state.enPassant.y,
        enPassant: true
      });
    }
  }

  return moves;
};

/* ----- —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ ----- */
const oldKingMoves = getPseudoMoves;
getPseudoMoves = function(x, y, piece) {
  let moves = oldKingMoves(x, y, piece);
  if (piece[1] !== "k") return moves;

  const color = piece[0];
  const row = color === "w" ? 7 : 0;
  const rights = state.castling[color];

  if (y === row && x === 4 && !isKingInCheck(state.board, color === "w" ? "white" : "black")) {
    // –∫–æ—Ä–æ—Ç–∫–∞—è
    if (rights.king && rights.rookH &&
        !state.board[row][5] && !state.board[row][6]) {
      moves.push({ x: 6, y: row, castle: "short" });
    }
    // –¥–ª–∏–Ω–Ω–∞—è
    if (rights.king && rights.rookA &&
        !state.board[row][1] && !state.board[row][2] && !state.board[row][3]) {
      moves.push({ x: 2, y: row, castle: "long" });
    }
  }
  return moves;
};

/* ----- –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–ø–µ—Ü—Ö–æ–¥—ã ----- */
const oldMakeMoveFinal = makeMove;
makeMove = function(fx, fy, tx, ty) {
  const piece = state.board[fy][fx];
  const move = state.legalMoves.find(m => m.x === tx && m.y === ty);

  state.history.push({
    board: cloneBoard(state.board),
    turn: state.turn,
    castling: JSON.parse(JSON.stringify(state.castling)),
    enPassant: state.enPassant
  });

  // en passant
  if (move && move.enPassant) {
    state.board[fy][tx] = "";
  }

  // —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
  if (move && move.castle) {
    if (move.castle === "short") {
      state.board[fy][5] = state.board[fy][7];
      state.board[fy][7] = "";
    } else {
      state.board[fy][3] = state.board[fy][0];
      state.board[fy][0] = "";
    }
  }

  // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ en passant
  state.enPassant = null;
  if (piece[1] === "p" && Math.abs(ty - fy) === 2) {
    state.enPassant = { x: fx, y: (fy + ty) / 2 };
  }

  // –æ—Ç–∫–ª—é—á–∞–µ–º —Ä–æ–∫–∏—Ä–æ–≤–∫—É
  if (piece[1] === "k") {
    state.castling[piece[0]].king = false;
  }
  if (piece[1] === "r") {
    if (fx === 0) state.castling[piece[0]].rookA = false;
    if (fx === 7) state.castling[piece[0]].rookH = false;
  }

  oldMakeMoveFinal(fx, fy, tx, ty);

  if (state.turn !== state.playerColor) {
    setTimeout(aiMove, 300);
  }
};

/* =====================================================
   ü§ñ –ò–ò ‚Äî MINIMAX + ALPHA-BETA
===================================================== */

function evaluateBoard(board) {
  const values = { p:1, n:3, b:3, r:5, q:9, k:1000 };
  let score = 0;
  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p = board[y][x];
      if (!p) continue;
      score += (p[0] === "w" ? 1 : -1) * values[p[1]];
    }
  return score;
}

function minimax(board, depth, alpha, beta, maximizing) {
  if (depth === 0) return evaluateBoard(board);

  let best = maximizing ? -Infinity : Infinity;
  const color = maximizing ? "black" : "white";

  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p = board[y][x];
      if (!p || (maximizing ? p[0] !== "b" : p[0] !== "w")) continue;

      const moves = getLegalMoves(x,y);
      for (const m of moves) {
        const copy = cloneBoard(board);
        copy[m.y][m.x] = p;
        copy[y][x] = "";

        const val = minimax(copy, depth-1, alpha, beta, !maximizing);
        if (maximizing) {
          best = Math.max(best, val);
          alpha = Math.max(alpha, val);
        } else {
          best = Math.min(best, val);
          beta = Math.min(beta, val);
        }
        if (beta <= alpha) return best;
      }
    }
  return best;
}

function aiMove() {
  let bestScore = Infinity;
  let bestMove = null;

  for (let y=0;y<8;y++)
    for (let x=0;x<8;x++) {
      const p = state.board[y][x];
      if (!p || p[0] !== "b") continue;

      const moves = getLegalMoves(x,y);
      for (const m of moves) {
        const copy = cloneBoard(state.board);
        copy[m.y][m.x] = p;
        copy[y][x] = "";

        const score = minimax(copy, state.difficulty, -Infinity, Infinity, true);
        if (score < bestScore) {
          bestScore = score;
          bestMove = { fx:x, fy:y, tx:m.x, ty:m.y };
        }
      }
    }

  if (bestMove) {
    makeMove(bestMove.fx, bestMove.fy, bestMove.tx, bestMove.ty);
    commentMove(bestScore);
  }
}

/* =====================================================
   üí¨ –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò –•–û–î–û–í
===================================================== */

function commentMove(score) {
  const el = document.getElementById("comment");
  if (score < -5) el.textContent = "–ó–µ–≤–æ–∫";
  else if (score < -2) el.textContent = "–ù–µ—Ç–æ—á–Ω—ã–π —Ö–æ–¥";
  else if (score < 1) el.textContent = "–•–æ—Ä–æ—à–∏–π —Ö–æ–¥";
  else if (score < 4) el.textContent = "–û—Ç–ª–∏—á–Ω—ã–π —Ö–æ–¥";
  else el.textContent = "–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω—ã–π —Ö–æ–¥";
}